#' ---
#' title: "Getting started with the *repo* R Data Manager"
#' date:
#' author: "Francesco Napolitano"
#' output:
#'   html_document:
#'     theme: default
#'     toc: true
#'     self_contained: false
#' 
#' ---
#' 

#' <br>
#' <p style="text-align:center">**_"Thou Shalt Not save() Or load()"_**</p>
#' <br>
#'
#'## Introduction
#' 
#' This is a short getting-started guide to the *repo* R package,
#' which implements an R objects repository manager. The motivations
#' behind the development of *repo* concern both scientific
#' considerations, as a tool to improve reproducibility in
#' computational research, and practical, as a solution to everyday
#' problems of people working in the same fields.
#'
#' Data analysis is a data-multiplication activity. Starting from an
#' initial resource, derived ones are built, each of which can be used
#' in turn to build more. After working for a while in this area,
#' simple repetitive tasks such as locating a resource built in the
#' past (what was its name? in which directory was it stored? for which
#' project? on which machine?) or remembering how it had been made
#' (which model?  which parameters?  which script?) can quickly become
#' daunting.
#'
#' The *repo* package tries to help with such everyday issues. It
#' builds one (or more) centralized repository where R objects are
#' stored together with corresponding annotations, tags, dependency
#' notes, provenance traces. Once a repository has been populated, the
#' user is presented with a structured collection of all the stored
#' resources, which can be easily explored, navigated, modified,
#' imported and exported.
#'
#' The author of this tool is definitely aware of how much the idea of
#' any additional work put between a researcher and his final results
#' is doomed to be rejected. This is why *repo* has been designed with
#' the aim of producing as little overhead as possible to the data
#' storage phase (while it will save a lot of time in later
#' phases). The tool tries to encourage you in putting some structure
#' into your data, but will step aside if you have good reasons not
#' to.
#' 
#' Main features include:
#'
#' * Store R objects in a central repository
#' * Retrieve any stored object simply by its name
#' * Store object description, tags, provenance trace
#' * Search items by names or tags
#' * Show details repository-wise or item-wise
#' * Build and plot items dependency trees
#' * Attach regular files to repo items
#' * Run system commands on stored attachments
#' * Quickly store temporary data
#' * Store multiple versions of the same resource
#' * Concurrent access to the same repository
#' * Copy items between repositories
#' * Export items back to regular R data files
#' * Check repository integrity through MD5 checksums
#'
#' What follows is a walk-through aimed at quickly introducing to most
#' of the *repo* features. It will guide you through the creation of a
#' repository with a few items and show the most common operations
#' that can be performed on it.
#' 
#'## Preparation
#'
#' In this section, some global variables will be defined and the
#' necessary libraries loaded. First of all, the following will enable
#' repo:

#+ include=FALSE
system("rm -r repodemo")

#+ eval=FALSE
library(repo)

#' Among annotations that can be added to items stored in the repo
#' there's the provenance trace, which basically answers the question:
#' where does this come from? The following string will be used as a
#' provenance trace for all the data produced by this script. It is
#' basically the full path to the file containing this script (the
#' documentation you're reading has been generated by a script called
#' *repodemo.R*).
#' 

src <- normalizePath("repodemo.R")

#' The following command creates a new repo in "./repodemo" or open an
#' existing one in the same directory (by default, instead, the repo
#' is created in "~/.R_repo"). To avoid confirmation requests during
#' the generation of this document, they're turned off through the
#' *forceYes* parameter. The variable *repo* will be used as the main
#' interface to the repository.
#'
repo <- repo_open("repodemo", forceYes=T)

#+ include=FALSE
library(knitr)
opts_chunk$set(comment=NA)
dorun <- F

#'## Populating the repository
#' 
#' In this section, some data will be stored inside the repository
#' just created. In particular, such data will include the Iris
#' dataset (bundled with most R distributions), a
#' dimensionality-reduction version of the same data (through
#' Principal Component Analysis - PCA) and a clustering (through
#' K-means). Also, some visualization will be *attached* in the
#' repo. Attached items are generated from generic files on the disk
#' as opposed to R objects in the current environment.
#' 
#' 
#' ### Storing a dataset
#'
#' The Iris dataset is readily found in the *datasets* R
#' package. However, we will store a normalized version of it in the
#' repo. The code for normalization is a simple call to the
#' *scale* R function:

myiris <- scale(as.matrix(iris[,1:4]))

#' In order to properly store the normalized *myiris*, a call to
#' *repo$put* will provide the following parameters:
#'
#' * **obj** The varialbe containing the object that we want to store:
#' *myiris*.
#' 
#' * **name** An identifier for the variable. At the moment any string is
#' accepted, but this may change in favor of sanitized names. Best
#' practice is to use a short name without special characters.
#'
#' * **description** A verbose description of the variable contents.
#'
#' * **tags** A set of tags. Tags are used to subset the repo for many
#' purposes. For example in order to be able to select only items
#' produced by this script, a specific tag will be added accordingly
#' (*repodemo*).
#'
#' * **src** Filename containing the source code that generated the
#' object being *put*.
#' 
#' * **replace** A boolean that tells repo whether to overwrite any
#' existing entry by the same name. Setting it to *true* allows to run
#' a script over without interruptions.
#'
#' Thus, the following call to the *put* method will store the
#' contents of *myiris* in the repo. The data will be actually saved
#' in the repo root in RDS format.

repo$put(
    obj = myiris,    
    name = "myiris",    
    description = paste(
        "A normalized version of the iris dataset coming with R.",
        "Normalization is made with the scale function",
        "with default parameters."
    ),
    tags = c("dataset", "iris", "repodemo"),    
    src = src,    
    replace=T
)

#' In our example, the class annotation is stored separately. Here's a
#' more compact call to *put*:

repo$put(iris$Species, "irisLabels", "The Iris class lables.",
         c("labels", "iris", "repodemo"), src, replace=T)

#'### Attaching visualizations
#'
#' The Iris dataset is 4D and PCA can be used to produce a 2D
#' visualization. The following code produces such visualization
#' and shows it:
#' 
irispca <- princomp(myiris)        
iris2d <- irispca$scores[,c(1,2)]
plot(iris2d, main="2D visualization of the Iris dataset",
     col=repo$get("irisLabels"))

#' Note that *irisLabels* is taken on the fly from the repo. During
#' this script, the variable is used three times, thus implying three
#' disk accesses. This could be considered bad practice, however I
#' will keep it as a quick hack example.
#' 
#' Wouldn't it be nice to store the visualization itself in the repo
#' and somehow link it to the iris data? This can be done exploiting
#' the *attach* method, which can store any file in the repo as is,
#' together with usual annotations (description, tags,
#' etc.). Internally, *attach* calls *put*, so it accepts most of its
#' parameters. However, two differences are worth noting:
#'
#' * **filepath** Instead of an identifier, *attach* takes a file name
#' (with path). The file name will be also the item identifier. This
#' behavior can be overridden by calling *put* with the
#' *asattachment* parameter set to TRUE.
#'
#' * **to** This optional parameter tells repo which item this one is
#' attached to.
#' 
pdf("iris2D.pdf")
plot(iris2d, main="2D visualization of the Iris dataset",
     col=repo$get("irisLabels"))
invisible(dev.off())
repo$attach("iris2D.pdf", "Iris 2D visualization obtained with PCA.",
            c("visualization", "iris", "repodemo"), src, replace=T, to="myiris")
#'
#' *attach* actually creates a copy of the attached file in the repo
#' root, so the one in the working directory can be safely removed:

invisible(file.remove("iris2D.pdf"))

#' Wanna see something cool? The attached PDF can be opened using an
#' external PDF viewer directly from repo through the *sys* method. On
#' a Linux system, this command will run the Evince document viewer
#' and show *iris2D.pdf*:

#+ eval=FALSE
repo$sys("iris2D.pdf", "evince")

#' Back to data analysis, is the 2D visualization good enough for a 4D
#' dataset? This can be checked by looking at the PCA eigenvalues, as
#' follows.

plot(irispca)

#' In the future, when looking at the 2D visualization, one may want
#' to remember its "accuracy" according to the PCA eigenvalues
#' above. So attaching the plot of the PCA eigenvalues to the plot of
#' the 2D visualization could be a good idea. This is attaching to an
#' attachment and is OK.

pdf("irispca.pdf")
plot(irispca)
invisible(dev.off())
repo$attach("irispca.pdf", "Variance explained by the PCs of the Iris dataset",
            c("visualization", "iris", "repodemo"), src, replace=T, to="iris2D.pdf")
invisible(file.remove("irispca.pdf"))

#'### Storing results
#'
#' The following code makes a clustering of the Iris data and stores
#' it in the repo. There still one more interesting parameter here:
#'
#' * **depends** This tells repo that, in order to compute the *kiris*
#' variable containing the clustering, data previously stored will be
#' necessary, namely *myiris*. This dependency annotation is not
#' mandatory, however it helps to keep things sorted as the repo
#' grows. Literature on Reproducible Research agrees on the importance
#' of "provenance traces": setting this value is definitely encouraged
#' practice.

kiris <- kmeans(myiris, 5)$cluster
repo$put(kiris, "iris_5clu", "Kmeans clustering of the Iris data, k=5.",
         c("metadata", "iris", "kmeans", "clustering", "repodemo"), src,
         depends="myiris", T)

#'
#' Let's see what the clustering looks like. This is the same 2D
#' visualization as before, except that colors are given by clustering
#' labels instead of class labels. 
plot(iris2d, main="Iris dataset kmeans clustering", col=kiris)

#' Just for the purpose of making the repo a bit more interesting, we
#' will *attach* this visualization as well. Note the dependency.

pdf("iris2Dkm.pdf")
plot(iris2d, main="Iris dataset kmeans clustering", col=kiris)
invisible(dev.off())
repo$attach("iris2Dkm.pdf", "Iris K-means clustering.",
            c("visualization", "iris", "clustering", "kmeans", "repodemo"), src,
            replace=T, to="iris_5clu")
invisible(file.remove("iris2Dkm.pdf"))

#'
#' Finally, let's compute a contingency table of the classes versus
#' clusters and store it in the repo. Let's assume that for some
#' reason we don't really care about this precise result, but we think
#' it could be useful in the future. This is the use case for the tag
#' *hide*, which prevents an item from being shown by
#' default. Attachments are automatically *hide*-tagged by default.
#' 
res <- table(repo$get("irisLabels"), kiris)
repo$put(res, "iris_cluVsSpecies",
         paste("Contingency table of the kmeans clustering versus the",
               "original labels of the Iris dataset."),
         c("result", "iris","validation", "clustering", "repodemo", "hide"),
         src, c("myiris", "irisLabels", "iris_5clu"), T)

#'## Looking at the repository
#' 
#' In this section a few basic commands to show repository-wide
#' information will be introduced, namely repository summary and
#' dependency graphs.
#' 
#' ### Repository summary
#' 
#' The *info* method provides details about repo items, but when
#' called without arguments it shows some self-explaining information
#' about the repo:
#' 
repo$info()

#' ### Listing items
#'
#' The repo library supports an S3 *print* method that shows the
#' contents of the repo. All non-hidden items will be shown, together
#' with some details, which by defaults are: name, dimensions, size.
#'
repo ## by default resolves to print(repo)
#'
#' As expected, hidden items are not shown. Use the following to make
#' all the items appear:
#'
print(repo, all=T)
#'
#' Items can also be listed selectively. With the following call, only
#' items tagged with "clustering" will be shown:
#' 
print(repo, tags="clustering", all=T)
#'
#' All attachments have the *attachment* tag, so they can be
#' selectively visualized this way:
#' 
print(repo, tags="attachment", all=T)
#'
#' For the same reasons, one may want to show only hidden items:

print(repo, tags="hide", all=T)

#' Finally, also the columns shown can be selected. Let's show only the
#' tags:

repo$print(show="t", all=T)

#'### Showing dependencies
#'
#' In the previous sections we set dependencies for some items, in
#' order to remember that they needed other items to be computed. In
#' addition, some items were stored as attachment to other
#' items. Finally, we annotated all the items as being produced by
#' this script. In repo, all these relations are summarized in the
#' *dependency graph*. The formal representation of the graph is a
#' matrix, in which the entry (i,j) represent a relation from i to j
#' of type 1, 2 or 3 (*dependency*, *attachment* or
#' *generation*). Here's how it looks like (after removing full paths
#' from the file names in the graph):

depgraph <- repo$dependencies(plot=F)
rownames(depgraph) <- colnames(depgraph) <- basename(rownames(depgraph))
kable(depgraph)

#' Omitting the *plot=F* parameter, the *dependencies* method will
#' plot the dependency graph. This plot requires the *igraph* library.
#' 
repo$dependencies()

#'
#' This is a small repo and all resources were created by the same
#' script, so the "generated" edges are not interesting. The three
#' types of edges can be shown selectively, so here's how the graph
#' looks like without the "generated" edges:
#' 
repo$dependencies(generated=F)

#'## Accessing items in the repo
#'
#' Of course, the only purpose of storing things is to retrieve them
#' later, and this is why the most used command in repo is *get*. It's
#' meaning is very straightforward. The following command retrieves
#' the variable *myiris* from the repo and loads it into the variable
#' *x* in the current environment.
#'
x <- repo$get("myiris")

#' To get additional information about the entry, the *info* command
#' can be used this way:
repo$info("myiris")

#'## Item versions and temporary items
#'
#' There are actually 4 different ways of adding an object to the
#' repo:
#'
#' * Add a new object (*repo$put*)
#' * Overwrite an existing object (*repo$put(replace=T)*)
#' * Add a new version of an existing object (*repo$put(addversion = T)*)
#' * Stash an object as temporary (*repo$stash*)
#'
#' The first two were covered before, this section will deal with the
#' other other two.
#'
#'### Versioning
#' 
#' If you're into Machine Learning, you know that if you run K-means
#' twice, you're likely going to get two different solutions. Suppose
#' we want to store such an alternative solution as an additional
#' version of the *iris_5clu* item. This can be done as follows:

kiris2 <- kmeans(myiris, 5)$cluster
repo$put(kiris, "iris_5clu",
         "Kmeans clustering of the Iris data, k=5. Today's version!",
         c("metadata", "iris", "kmeans", "clustering", "repodemo"), src,
         depends="myiris", addversion=T)

#' * **addversion** when TRUE, tells repo to add a new version of an
#' existing object. The new object will replace the old one and the
#' old one will be renamed adding the suffix "#N", with N being an
#' incremental integer.
#'
#' The new repo looks like the old one:

repo

#' Except that *iris_5clu* is actually the new one (look at the
#' description):

repo$info("iris_5clu")

#' while the old one has been renamed and hidden:

repo$print(all=T)

#' However, it can be referred to as any other repo item:

repo$info("iris_5clu#1")

#'### Stashing
#'
#' Repo tries to force the user into building a structured and
#' annotated repository. However, this implies a tiny overhead that in
#' some cases may not be justified. This is when stashing comes
#' handy.
#'
#' Consider the case of caching intermediate results. Intermediate
#' results are not going to be used directly, however they will save
#' time in case the final results have to be generated again. In such
#' cases one can just store the intermediate results without
#' specifying annotations: this is called *stashing*.
#'
#' Below is a fake computation that takes 10 secs and that one does
#' not want to perform during, for example, report generation. One may
#' set the *dorun* variable to FALSE (btw that's my personal practice)
#' so that the script will *get* the precomputed variable from the
#' repo.

#+ include=FALSE
result <- "This took 10 seconds to compute"
repo$stash("result")

#+ eval=FALSE
if(dorun) {
    Sys.sleep(10)
    result <- "This took 10 seconds to compute"
    repo$stash("result")
} else result <- repo$get("result")

#' The *stash* function has a rather rough behavior: it will search
#' the object by name int the caller environment, create some generic
#' descriptions and tags, *put* the object into the repo overwriting
#' stashed items by the same name, and finally hide the newly created
#' item.

repo$info("result")

#'## Handlers
#'
#' It's a shame that the auto-completion feature by your favorite
#' editor can not be used on repo item names. Except it can. The
#' *handlers* method returns a list of functions by the same names of
#' the items in the repo. Each of these functions can call repo
#' methods (*get* by default) on the corresponding items. Easier by
#' examples:

h <- repo$handlers()
names(h)
#' Handlers call *get* by default:
print(h$iris_cluVsSpecies())
#' The *tag* method (not yet described)  adds a tag to an item:
h$iris_cluVsSpecies("tag", "onenewtag")
h$iris_cluVsSpecies("info")
#' One may want to open a repo directly with:

#+ message=FALSE
h <- repo_open("repodemo")$handlers()

#' In that case, the handler to the repo itself will come handy:

h$repo

#' If items are removed or added, you may want to refresh the
#' handlers:

h <- h$repo$handlers()

#'## Other features
#'
#' You can easily get a list of repo methods by:

names(repo)

#' Here's a very short summary:

#+ echo=FALSE
feattable <- matrix(
    c("rm", "remove an item",
      "export", "save an item's object to a regular RDS file",
      "set", "edit an existing entry",
      "tag", "add a tag to an existing entry",
      "untag", "remove a tag from an existing entry",
      "sys", "execute a system command on the file referred to by an item",
      "tags", "show the complete list of tags in the repo",
      "check", "check repository integrity",
      "stashclear", "remove all stashed items",
      "root", "get the repo root path"), ncol=2, byrow=T)
colnames(feattable) <- c("Method", "Description")

kable(feattable)



<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Francesco Napolitano" />


<title>Getting started with the repo R Data Manager</title>

<script src="index_files/jquery-1.11.0/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="index_files/bootstrap-3.3.1/css/bootstrap.min.css" rel="stylesheet" />
<script src="index_files/bootstrap-3.3.1/js/bootstrap.min.js"></script>
<script src="index_files/bootstrap-3.3.1/shim/html5shiv.min.js"></script>
<script src="index_files/bootstrap-3.3.1/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="index_files/highlight/default.css"
      type="text/css" />
<script src="index_files/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img { 
  max-width:100%; 
  height: auto; 
}
</style>
<div class="container-fluid main-container">


<div id="header">
<h1 class="title">Getting started with the <em>repo</em> R Data Manager</h1>
<h4 class="author"><em>Francesco Napolitano</em></h4>
</div>

<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#preparation">Preparation</a></li>
<li><a href="#populating-the-repository">Populating the repository</a><ul>
<li><a href="#storing-data-in-the-repository">Storing data in the repository</a></li>
<li><a href="#attaching-visualizations">Attaching visualizations</a></li>
<li><a href="#storing-results">Storing results</a></li>
</ul></li>
<li><a href="#looking-at-the-repository">Looking at the repository</a><ul>
<li><a href="#showing-dependencies">Showing dependencies</a></li>
</ul></li>
<li><a href="#accessing-items-in-the-repo">Accessing items in the repo</a></li>
<li><a href="#item-versions-and-temporary-items">Item versions and temporary items</a><ul>
<li><a href="#versioning">Versioning</a></li>
<li><a href="#stashing">Stashing</a></li>
</ul></li>
<li><a href="#handlers">Handlers</a></li>
<li><a href="#other-features">Other features</a></li>
</ul>
</div>

<br>
<p style="text-align:center">
<strong><em>“Thou Shalt Not save() Or load()”</em></strong>
</p>
<p><br></p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This is a getting-started guide to the <em>repo</em> R package, which implements an R objects repository manager. The motivations behind the development of <em>repo</em> concern both scientific considerations, as a tool to improve reproducibility in computational research, and practical, as a solution to everyday problems of people working in the same fields.</p>
<p>Data analysis is a also a data multiplication activity. Starting from an initial resource, derived ones are built, each of which can be used in turn to build more processed data. After working for a while on data analysis projects, simple repetitive tasks such as locating a resource built in the past (what was its name? in which directory was it stored? for which project? on which machine?) or remembering how it had been made (which model? which parameters? which script?) can quickly become daunting.</p>
<p>The <em>repo</em> package tries to help with such everyday issues. It builds one (or more) centralized local repository where R objects are stored together with corresponding annotations, tags, dependency notes, provenance traces. Once a repository has been populated, the user is presented with a structured collection of all the stored resources, which can be easily explored, navigated, modified, imported and exported.</p>
<p>Main features include:</p>
<ul>
<li>Store R objects in a central repository</li>
<li>Retrieve any stored object simply by its name</li>
<li>Store object description, tags, provenance trace</li>
<li>Search items by names or tags</li>
<li>Show details repository-wise or item-wise</li>
<li>Build and plot items dependency trees</li>
<li>Attach regular files to repo items</li>
<li>Run system commands on stored attachments</li>
<li>Quickly store temporary data</li>
<li>Store multiple versions of the same resource</li>
<li>Concurrent access to the same repository</li>
<li>Copy items between repositories</li>
<li>Export items back to regular R data files</li>
<li>Check repository integrity through MD5 checksums</li>
</ul>
<p>What follows is a walk-through aimed at quickly introducing to most of the <em>repo</em> features.</p>
</div>
<div id="preparation" class="section level2">
<h2>Preparation</h2>
<p>First of all, the following will enable repo:</p>
<pre class="r"><code>library(repo)</code></pre>
<p>The fully qualified name of a script file is a good provenance trace for all the data produced by the script. It can be obtained like this:</p>
<pre class="r"><code>src &lt;- normalizePath(&quot;repodemo.R&quot;)</code></pre>
<p>However, for this guide full paths from my hard drive will be hidden:</p>
<pre class="r"><code>src &lt;- &quot;repodemo.R&quot;</code></pre>
<p>The following command creates a new repository in “./repodemo” (by default the repo is created in “~/.R_repo”) or open an existing one in the same directory. To avoid confirmation requests during the generation of this document, they’re turned off through the <em>force</em> parameter. The variable <em>repo</em> will be used as the main interface to the repository throughout this guide.</p>
<pre class="r"><code>repo &lt;- repo_open(&quot;repodemo&quot;, force=T)</code></pre>
<pre><code>## Repo root created.
## Repo created.</code></pre>
</div>
<div id="populating-the-repository" class="section level2">
<h2>Populating the repository</h2>
<p>In this section, some data will be stored inside the repository just created, namely: a normalized version of the Iris dataset; a dimensionality-reduced and a clustering of the same data; some visualizations.</p>
<div id="storing-data-in-the-repository" class="section level3">
<h3>Storing data in the repository</h3>
<p>The Iris dataset is readily found in the <em>datasets</em> R package. However, here a normalized version of it will be stored in the repo. Here’s the data to store:</p>
<pre class="r"><code>myiris &lt;- scale(as.matrix(iris[,1:4]))</code></pre>
<p>A call to <em>repo$put</em> will provide the following parameters to properly store the object in the repository:</p>
<ul>
<li><p><strong>obj</strong> The variable containing the object to store: <em>myiris</em>.</p></li>
<li><p><strong>name</strong> An identifier for the variable. At the moment any string is accepted, but this may change in favor of sanitized names. Best practice is to use a short name without special characters.</p></li>
<li><p><strong>description</strong> A verbose description of the variable contents.</p></li>
<li><p><strong>tags</strong> A set of tags. Tags are used to subset the repo for many purposes. For example in order to be able to select only items produced by this script, a specific tag will be added accordingly (<em>repodemo</em>).</p></li>
<li><p><strong>src</strong> Name of the file containing the source code that generated the object being <em>put</em>. This part of the object’s “provenance trace”.</p></li>
<li><p><strong>replace</strong> A logical that tells <em>repo</em> whether to overwrite an existing entry by the same name. Setting it to <em>true</em> allows to run a script over without interruptions.</p></li>
</ul>
<p>Thus, the following call to the <em>put</em> method will store the contents of <em>myiris</em> in the repo. The data will be actually saved in the repo root in RDS format.</p>
<pre class="r"><code>repo$put(
    obj = myiris,    
    name = &quot;myiris&quot;,    
    description = paste(
        &quot;A normalized version of the iris dataset coming with R.&quot;,
        &quot;Normalization is made with the scale function&quot;,
        &quot;with default parameters.&quot;
    ),
    tags = c(&quot;dataset&quot;, &quot;iris&quot;, &quot;repodemo&quot;),    
    src = src,    
    replace=T
)</code></pre>
<p>In this example, the class annotation will be stored separately. Here’s a more compact call to <em>put</em>:</p>
<pre class="r"><code>repo$put(iris$Species, &quot;irisLabels&quot;, &quot;The Iris class lables.&quot;,
         c(&quot;labels&quot;, &quot;iris&quot;, &quot;repodemo&quot;), src, replace=T)</code></pre>
</div>
<div id="attaching-visualizations" class="section level3">
<h3>Attaching visualizations</h3>
<p>The Iris dataset is 4D and PCA can be used to produce a 2D visualization. The following code produces such visualization and shows it:</p>
<pre class="r"><code>irispca &lt;- princomp(myiris)        
iris2d &lt;- irispca$scores[,c(1,2)]
plot(iris2d, main=&quot;2D visualization of the Iris dataset&quot;,
     col=repo$get(&quot;irisLabels&quot;))</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" title="" alt="" width="672" /></p>
<p>Note that <em>irisLabels</em> is taken on the fly from the repo. This prevents the creation of a variable in the current environment and can sometimes be convenient.</p>
<p>Wouldn’t it be nice to store the figure itself in the repo and somehow link it to the iris data? This can be done exploiting the <em>attach</em> method, which can store any file in the repo as is, together with usual annotations (description, tags, etc.). Internally, <em>attach</em> calls <em>put</em>, so it accepts most of its parameters. However, two differences are worth noting:</p>
<ul>
<li><p><strong>filepath</strong> Instead of an identifier, <em>attach</em> takes a file name (with path). The file name will be also the item identifier.</p></li>
<li><p><strong>to</strong> This optional parameter tells repo which item the new one is attached to.</p></li>
</ul>
<pre class="r"><code>pdf(&quot;iris2D.pdf&quot;)
plot(iris2d, main=&quot;2D visualization of the Iris dataset&quot;,
     col=repo$get(&quot;irisLabels&quot;))
invisible(dev.off())
repo$attach(&quot;iris2D.pdf&quot;, &quot;Iris 2D visualization obtained with PCA.&quot;,
            c(&quot;visualization&quot;, &quot;iris&quot;, &quot;repodemo&quot;), src, replace=T, to=&quot;myiris&quot;)</code></pre>
<p><em>attach</em> actually creates a copy of the attached file in the repo root, so the original one can be safely removed:</p>
<pre class="r"><code>invisible(file.remove(&quot;iris2D.pdf&quot;))</code></pre>
<p>Wanna see something even nicer? The attached PDF can be opened using an external PDF viewer directly from repo through the <em>sys</em> method. On a Linux system, this command will run the Evince document viewer and show <em>iris2D.pdf</em>:</p>
<pre class="r"><code>repo$sys(&quot;iris2D.pdf&quot;, &quot;evince&quot;)</code></pre>
<p>Back to data analysis, the PCA eigenvalues showed below can give hints on the reliability of the 2D plot:</p>
<pre class="r"><code>plot(irispca)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-14-1.png" title="" alt="" width="672" /></p>
<p>So attaching the plot of the PCA eigenvalues to the plot of the 2D visualization could be a good idea. This is attaching to an attachment and is OK.</p>
<pre class="r"><code>pdf(&quot;irispca.pdf&quot;)
plot(irispca)
invisible(dev.off())
repo$attach(&quot;irispca.pdf&quot;, &quot;Variance explained by the PCs of the Iris dataset&quot;,
            c(&quot;visualization&quot;, &quot;iris&quot;, &quot;repodemo&quot;), src, replace=T, to=&quot;iris2D.pdf&quot;)
invisible(file.remove(&quot;irispca.pdf&quot;))</code></pre>
</div>
<div id="storing-results" class="section level3">
<h3>Storing results</h3>
<p>The following code makes a clustering of the Iris data and stores it in the repo. There is still one parameter to note here:</p>
<ul>
<li><strong>depends</strong> This tells repo that, in order to compute the <em>kiris</em> variable containing the clustering, data previously stored will be necessary, namely <em>myiris</em>. This dependency annotation is not mandatory, however it helps to keep things sorted as the repo grows. Literature on Reproducible Research agrees on the importance of “provenance traces”: setting this value is definitely encouraged practice.</li>
</ul>
<pre class="r"><code>kiris &lt;- kmeans(myiris, 5)$cluster
repo$put(kiris, &quot;iris_5clu&quot;, &quot;Kmeans clustering of the Iris data, k=5.&quot;,
         c(&quot;metadata&quot;, &quot;iris&quot;, &quot;kmeans&quot;, &quot;clustering&quot;, &quot;repodemo&quot;), src,
         depends=&quot;myiris&quot;, T)</code></pre>
<p>The following shows what the clustering looks like. The figure will be attached to the repo as well. Note the dependency.</p>
<pre class="r"><code>plot(iris2d, main=&quot;Iris dataset kmeans clustering&quot;, col=kiris)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-17-1.png" title="" alt="" width="672" /></p>
<pre class="r"><code>pdf(&quot;iris2Dkm.pdf&quot;)
plot(iris2d, main=&quot;Iris dataset kmeans clustering&quot;, col=kiris)
invisible(dev.off())
repo$attach(&quot;iris2Dkm.pdf&quot;, &quot;Iris K-means clustering.&quot;,
            c(&quot;visualization&quot;, &quot;iris&quot;, &quot;clustering&quot;, &quot;kmeans&quot;, &quot;repodemo&quot;), src,
            replace=T, to=&quot;iris_5clu&quot;)
invisible(file.remove(&quot;iris2Dkm.pdf&quot;))</code></pre>
<p>Finally, the last part of the analysis computes a contingency table of the classes versus clusters. Let’s assume that this analysis is meant to be qualitatively, so the table is not really important. However it could come handy in the future. This is a possible use case for the special tag <em>hide</em>, which prevents an item from being shown by default. Attachments are automatically <em>hide</em>-tagged.</p>
<pre class="r"><code>res &lt;- table(repo$get(&quot;irisLabels&quot;), kiris)
repo$put(res, &quot;iris_cluVsSpecies&quot;,
         paste(&quot;Contingency table of the kmeans clustering versus the&quot;,
               &quot;original labels of the Iris dataset.&quot;),
         c(&quot;result&quot;, &quot;iris&quot;,&quot;validation&quot;, &quot;clustering&quot;, &quot;repodemo&quot;, &quot;hide&quot;),
         src, c(&quot;myiris&quot;, &quot;irisLabels&quot;, &quot;iris_5clu&quot;), T)</code></pre>
</div>
</div>
<div id="looking-at-the-repository" class="section level2">
<h2>Looking at the repository</h2>
<p>The <em>info</em> method provides details about repo items, but when called without arguments it shows some self-explaining information about the repo:</p>
<pre class="r"><code>repo$info()</code></pre>
<pre><code>Root:            repodemo 
Number of items: 7 
Total size:      18.48 kB </code></pre>
<p>The repo library supports an S3 <em>print</em> method that shows the contents of the repo. All non-hidden items will be shown, together with some details, which by defaults are: name, dimensions, size.</p>
<pre class="r"><code>repo ## by default resolves to print(repo)</code></pre>
<pre><code>         ID  Dims    Size
     myiris 150x4 1.82 kB
 irisLabels   150   124 B
  iris_5clu   150   115 B</code></pre>
<p>As expected, hidden items are not shown. The following makes all the items appear:</p>
<pre class="r"><code>print(repo, all=T)</code></pre>
<pre><code>                ID  Dims    Size
            myiris 150x4 1.82 kB
        irisLabels   150   124 B
       @iris2D.pdf     - 5.84 kB
      @irispca.pdf     - 4.38 kB
         iris_5clu   150   115 B
     @iris2Dkm.pdf     - 6.02 kB
 iris_cluVsSpecies   3x5   179 B</code></pre>
<p>Items can also be listed selectively. With the following call, only items tagged with “clustering” will be shown:</p>
<pre class="r"><code>print(repo, tags=&quot;clustering&quot;, all=T)</code></pre>
<pre><code>                ID Dims    Size
         iris_5clu  150   115 B
     @iris2Dkm.pdf    - 6.02 kB
 iris_cluVsSpecies  3x5   179 B</code></pre>
<p>All attachments have the <em>attachment</em> tag, so they can be selectively visualized this way:</p>
<pre class="r"><code>print(repo, tags=&quot;attachment&quot;, all=T)</code></pre>
<pre><code>            ID Dims    Size
   @iris2D.pdf    - 5.84 kB
  @irispca.pdf    - 4.38 kB
 @iris2Dkm.pdf    - 6.02 kB</code></pre>
<p>For the same reasons, one may want to show only hidden items:</p>
<pre class="r"><code>print(repo, tags=&quot;hide&quot;, all=T)</code></pre>
<pre><code>                      
ID   iris_cluVsSpecies
Dims               3x5
Size             179 B</code></pre>
<p>Finally, also the columns shown can be selected. This command shows only the tags:</p>
<pre class="r"><code>repo$print(show=&quot;t&quot;, all=T)</code></pre>
<pre><code>                ID                                                 Tags
            myiris                              dataset, iris, repodemo
        irisLabels                               labels, iris, repodemo
       @iris2D.pdf                        visualization, iris, repodemo
      @irispca.pdf                        visualization, iris, repodemo
         iris_5clu         metadata, iris, kmeans, clustering, repodemo
     @iris2Dkm.pdf    visualization, iris, clustering, kmeans, repodemo
 iris_cluVsSpecies result, iris, validation, clustering, repodemo, hide</code></pre>
<div id="showing-dependencies" class="section level3">
<h3>Showing dependencies</h3>
<p>In the previous sections dependencies were set for some items. In addition, some items were stored as attachment to other items. Finally, all items were annotated as being produced by this script. In repo, all these relations are summarized in the <em>dependency graph</em>. The formal representation of the graph is a matrix, in which the entry (i,j) represent a relation from i to j of type 1, 2 or 3 (<em>dependency</em>, <em>attachment</em> or <em>generation</em>). Here’s how it looks like:</p>
<pre class="r"><code>depgraph &lt;- repo$dependencies(plot=F)
rownames(depgraph) &lt;- colnames(depgraph) &lt;- basename(rownames(depgraph))
kable(depgraph)</code></pre>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="right">myiris</th>
<th align="right">irisLabels</th>
<th align="right">iris2D.pdf</th>
<th align="right">irispca.pdf</th>
<th align="right">iris_5clu</th>
<th align="right">iris2Dkm.pdf</th>
<th align="right">iris_cluVsSpecies</th>
<th align="right">repodemo.R</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">myiris</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">irisLabels</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="left">iris2D.pdf</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">irispca.pdf</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="left">iris_5clu</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">iris2Dkm.pdf</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="left">iris_cluVsSpecies</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">repodemo.R</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<p>Omitting the <em>plot=F</em> parameter, the <em>dependencies</em> method will plot the dependency graph. This plot requires the <em>igraph</em> library.</p>
<pre class="r"><code>repo$dependencies()</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-27-1.png" title="" alt="" width="672" /></p>
<p>This is a small repo and all resources were created by the same script, so the “generated” edges are not interesting. The three types of edges can be shown selectively, so here’s how the graph looks like without the “generated” edges:</p>
<pre class="r"><code>repo$dependencies(generated=F)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-28-1.png" title="" alt="" width="672" /></p>
</div>
</div>
<div id="accessing-items-in-the-repo" class="section level2">
<h2>Accessing items in the repo</h2>
<p>Of course, the only purpose of storing things is to retrieve them later, and this is why the most used command in repo is <em>get</em>. It’s meaning is very straightforward. The following command retrieves the variable <em>myiris</em> from the repo and loads it into the variable <em>x</em> in the current environment.</p>
<pre class="r"><code>x &lt;- repo$get(&quot;myiris&quot;)</code></pre>
<p>To get additional information about the entry, the <em>info</em> command can be used this way:</p>
<pre class="r"><code>repo$info(&quot;myiris&quot;)</code></pre>
<pre><code>ID:           myiris
Description:  A normalized version of the iris dataset coming with R. Normalization is made with the scale function with default parameters.
Tags:         dataset, iris, repodemo
Dimensions:   150x4
Timestamp:    2015-07-12 22:06:05
Size on disk: 1.82 kB
Provenance:   repodemo.R
Attached to:  -
Stored in:    repodemo/ae/8c/b5/ae8cb58a595aa3446f10e9fa4dfd4954
MD5 checksum: 5c7af9e2f20958da3aec48e558ab8a32</code></pre>
</div>
<div id="item-versions-and-temporary-items" class="section level2">
<h2>Item versions and temporary items</h2>
<p>There are actually 4 different ways of adding an object to the repo:</p>
<ul>
<li>Add a new object (<em>repo$put</em>)</li>
<li>Overwrite an existing object (<em>repo$put(replace=T)</em>)</li>
<li>Add a new version of an existing object (<em>repo$put(addversion = T)</em>)</li>
<li>Stash an object as temporary (<em>repo$stash</em>)</li>
</ul>
<p>The first two were covered before, this section will deal with the other other two.</p>
<div id="versioning" class="section level3">
<h3>Versioning</h3>
<p>If you’re into Machine Learning, you know that if you run K-means twice, you’re likely going to get two different solutions. Suppose we want to store such an alternative solution as an additional version of the <em>iris_5clu</em> item. This can be done as follows:</p>
<pre class="r"><code>kiris2 &lt;- kmeans(myiris, 5)$cluster
repo$put(kiris, &quot;iris_5clu&quot;,
         &quot;Kmeans clustering of the Iris data, k=5. Today&#39;s version!&quot;,
         c(&quot;metadata&quot;, &quot;iris&quot;, &quot;kmeans&quot;, &quot;clustering&quot;, &quot;repodemo&quot;), src,
         depends=&quot;myiris&quot;, addversion=T)</code></pre>
<ul>
<li><strong>addversion</strong> when TRUE, tells repo to add a new version of an existing object. The new object will replace the old one and the old one will be renamed adding the suffix “#N”, with N being an incremental integer.</li>
</ul>
<p>The new repo looks like the old one:</p>
<pre class="r"><code>repo</code></pre>
<pre><code>         ID  Dims    Size
     myiris 150x4 1.82 kB
 irisLabels   150   124 B
  iris_5clu   150   115 B</code></pre>
<p>Except that <em>iris_5clu</em> is actually the one just put (look at the description):</p>
<pre class="r"><code>repo$info(&quot;iris_5clu&quot;)</code></pre>
<pre><code>ID:           iris_5clu
Description:  Kmeans clustering of the Iris data, k=5. Today&#39;s version!
Tags:         metadata, iris, kmeans, clustering, repodemo
Dimensions:   150
Timestamp:    2015-07-12 22:06:09
Size on disk: 115 B
Provenance:   repodemo.R
Attached to:  -
Stored in:    repodemo/ff/6d/ce/ff6dce2d056afd01f0e1f0b13bc0e295
MD5 checksum: 8e9d346dc430643fa6d76bb22169cab1</code></pre>
<p>while the old one has been renamed and hidden:</p>
<pre class="r"><code>repo$print(all=T)</code></pre>
<pre><code>                ID  Dims    Size
            myiris 150x4 1.82 kB
        irisLabels   150   124 B
       @iris2D.pdf     - 5.84 kB
      @irispca.pdf     - 4.38 kB
       iris_5clu#1   150   115 B
     @iris2Dkm.pdf     - 6.02 kB
 iris_cluVsSpecies   3x5   179 B
         iris_5clu   150   115 B</code></pre>
<p>However, it can be referred to as any other repo item:</p>
<pre class="r"><code>repo$info(&quot;iris_5clu#1&quot;)</code></pre>
<pre><code>ID:           iris_5clu#1
Description:  Kmeans clustering of the Iris data, k=5.
Tags:         metadata, iris, kmeans, clustering, repodemo, hide
Dimensions:   150
Timestamp:    2015-07-12 22:06:09
Size on disk: 115 B
Provenance:   repodemo.R
Attached to:  -
Stored in:    repodemo/ff/6d/ce/ff6dce2d056afd01f0e1f0b13bc0e295
MD5 checksum: 8e9d346dc430643fa6d76bb22169cab1</code></pre>
</div>
<div id="stashing" class="section level3">
<h3>Stashing</h3>
<p>Repo tries to force the user into building a structured and annotated repository. However, this implies a small overhead that in some cases may not be justified. This is when stashing comes handy.</p>
<p>Consider the case of caching intermediate results. Intermediate results are not going to be used directly, however they will save time in case the final results have to be generated again. In such cases one can just store the intermediate results without specifying annotations: in repo, this is called <em>stashing</em>.</p>
<p>Below is a fake computation that takes 10 secs and that one does not want to perform during, for example, report generation. One may set the <em>dorun</em> variable to FALSE (BTW that’s my personal practice) so that the script will <em>get</em> the precomputed variable from the repo.</p>
<pre class="r"><code>if(dorun) {
    Sys.sleep(10)
    result &lt;- &quot;This took 10 seconds to compute&quot;
    repo$stash(&quot;result&quot;)
} else result &lt;- repo$get(&quot;result&quot;)</code></pre>
<p>The <em>stash</em> function has a rather rough behavior: it will search the object <em>name</em> in the caller environment, create some generic descriptions and tags, <em>put</em> the object into the repo overwriting stashed items by the same name, and finally hide the newly created item.</p>
<pre class="r"><code>repo$info(&quot;result&quot;)</code></pre>
<pre><code>ID:           result
Description:  Stashed object
Tags:         stash, hide
Dimensions:   1
Timestamp:    2015-07-12 22:06:09
Size on disk: 74 B
Provenance:   /home/ciccio/git/gh-pages
Attached to:  -
Stored in:    repodemo/a5/1a/c6/a51ac6da0abd674507d667f47462fa17
MD5 checksum: 044889046af24c7dcdb77eb323b10106</code></pre>
</div>
</div>
<div id="handlers" class="section level2">
<h2>Handlers</h2>
<p>It’s a shame that the auto-completion feature by your favorite editor can not be used on repo item names. Except it can. The <em>handlers</em> method returns a list of functions by the same names of the items in the repo. Each of these functions can call repo methods (<em>get</em> by default) on the corresponding items. Easier by examples:</p>
<pre class="r"><code>h &lt;- repo$handlers()
names(h)</code></pre>
<pre><code> [1] &quot;myiris&quot;            &quot;irisLabels&quot;        &quot;iris2D.pdf&quot;       
 [4] &quot;irispca.pdf&quot;       &quot;iris_5clu#1&quot;       &quot;iris2Dkm.pdf&quot;     
 [7] &quot;iris_cluVsSpecies&quot; &quot;iris_5clu&quot;         &quot;result&quot;           
[10] &quot;repo&quot;             </code></pre>
<p>Handlers call <em>get</em> by default:</p>
<pre class="r"><code>print(h$iris_cluVsSpecies())</code></pre>
<pre><code>            kiris
              1  2  3  4  5
  setosa      0 25  0  0 25
  versicolor 29  0 19  2  0
  virginica  21  0  2 27  0</code></pre>
<p>The <em>tag</em> method (not yet described) adds a tag to an item:</p>
<pre class="r"><code>h$iris_cluVsSpecies(&quot;tag&quot;, &quot;onenewtag&quot;)
h$iris_cluVsSpecies(&quot;info&quot;)</code></pre>
<pre><code>ID:           iris_cluVsSpecies
Description:  Contingency table of the kmeans clustering versus the original labels of the Iris dataset.
Tags:         result, iris, validation, clustering, repodemo, hide, onenewtag
Dimensions:   3x5
Timestamp:    2015-07-12 22:06:10
Size on disk: 179 B
Provenance:   repodemo.R
Attached to:  -
Stored in:    repodemo/71/f4/85/71f48579b98958bc63ab72b6b49d08b4
MD5 checksum: 849ec1f74836dd22aa0c0e4ac7f0d7d8</code></pre>
<p>One may want to open a repo directly with:</p>
<pre class="r"><code>h &lt;- repo_open(&quot;repodemo&quot;)$handlers()</code></pre>
<p>In that case, the handler to the repo itself will come handy:</p>
<pre class="r"><code>h$repo</code></pre>
<pre><code>         ID  Dims    Size
     myiris 150x4 1.82 kB
 irisLabels   150   124 B
  iris_5clu   150   115 B</code></pre>
<p>If items are removed or added, handlers may need a refresh:</p>
<pre class="r"><code>h &lt;- h$repo$handlers()</code></pre>
</div>
<div id="other-features" class="section level2">
<h2>Other features</h2>
<p>The repo manual starts at:</p>
<pre class="r"><code>help(repo)</code></pre>
<p>All repo methods are also defined as functions in the global environment. Any call like <em>repo$func(x)</em> can be executed as <em>repo_func(repo, x)</em>. In order to get help on the function “func”, try the following:</p>
<pre class="r"><code>## help(repo_func)</code></pre>
<p>Here’s a summary of most repo functions:</p>
<table>
<thead>
<tr class="header">
<th align="left">Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">rm</td>
<td align="left">remove an item</td>
</tr>
<tr class="even">
<td align="left">export</td>
<td align="left">save an item’s object to a regular RDS file</td>
</tr>
<tr class="odd">
<td align="left">set</td>
<td align="left">edit an existing entry</td>
</tr>
<tr class="even">
<td align="left">tag</td>
<td align="left">add a tag to an existing entry</td>
</tr>
<tr class="odd">
<td align="left">untag</td>
<td align="left">remove a tag from an existing entry</td>
</tr>
<tr class="even">
<td align="left">sys</td>
<td align="left">execute a system command on the file referred to by an item</td>
</tr>
<tr class="odd">
<td align="left">tags</td>
<td align="left">show the complete list of tags in the repo</td>
</tr>
<tr class="even">
<td align="left">check</td>
<td align="left">check repository integrity</td>
</tr>
<tr class="odd">
<td align="left">stashclear</td>
<td align="left">remove all stashed items</td>
</tr>
<tr class="even">
<td align="left">root</td>
<td align="left">get the repo root path</td>
</tr>
</tbody>
</table>
</div>


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
